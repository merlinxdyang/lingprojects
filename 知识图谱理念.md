# 【我的观察】

## 事实层
- **数据规模**：6589条，完全在纯前端方案的可行范围内
- **明确约束**：不使用Pinecone等外部向量数据库API
- **技术方向**：静态网页 + OpenRouter大模型 + 本地向量计算

这个规模恰好处于**最佳实施区间**——既不会太小导致分析缺乏统计意义，也不会大到让浏览器难以处理。

## 情绪层
我感受到你对**自主可控性的重视**——不想被外部服务绑架，这是非常明智的选择。6589条数据的向量检索完全可以在现代浏览器中高效完成，无需依赖云服务。

---

# 【重新设计：纯前端知识图谱方案】

## 核心架构

```
静态资源层（GitHub Pages）
    ├─ index.html（主页面）
    ├─ vector-db.js（向量数据压缩包）
    ├─ search-engine.js（本地检索引擎）
    ├─ ai-analyzer.js（调用OpenRouter）
    └─ visualizations.js（图表渲染）

数据流：
用户输入 → 本地embedding生成 → WASM加速向量检索 
    → 筛选结果 → 调用OpenRouter分析 → 可视化呈现
```

---

# 【技术实现细节】

## 一、向量数据优化与加载

### 1. 数据压缩策略

你的原始数据每条约200KB（大部分是embedding数组），6589条总计约**1.3GB**，直接加载会崩溃。需要压缩：

```javascript
// 数据预处理脚本（在Node.js中运行）
const fs = require('fs');
const pako = require('pako'); // gzip压缩库

// 读取原始数据
const rawData = JSON.parse(fs.readFileSync('projects.json'));

// 分离向量和元数据
const metadata = rawData.map(item => ({
  id: item.id,
  name: item.name,
  year: item.year,
  category: item.category,
  leader: item.leader,
  org: item.org,
  tokens: item.name_tokens
}));

const embeddings = rawData.map(item => item.embedding);

// 将float数组转为Float32Array（减少50%存储）
const embeddingBuffer = new Float32Array(embeddings.flat());

// 压缩
const compressedEmbeddings = pako.gzip(
  new Uint8Array(embeddingBuffer.buffer)
);

// 输出
fs.writeFileSync('metadata.json', JSON.stringify(metadata));
fs.writeFileSync('embeddings.gz', compressedEmbeddings);

console.log(`压缩后大小: ${compressedEmbeddings.length / 1024 / 1024} MB`);
// 预计压缩到约150-200MB
```

### 2. 渐进式加载

```javascript
// 前端加载逻辑
class VectorDatabase {
  constructor() {
    this.metadata = null;
    this.embeddings = null;
    this.isReady = false;
  }

  async initialize() {
    // 先加载元数据（小文件，快速展示）
    this.metadata = await fetch('metadata.json').then(r => r.json());
    
    // 后台加载向量数据
    const compressed = await fetch('embeddings.gz').then(r => r.arrayBuffer());
    const decompressed = pako.ungzip(new Uint8Array(compressed));
    
    // 转回Float32Array
    this.embeddings = new Float32Array(decompressed.buffer);
    
    this.isReady = true;
    console.log('向量数据库已就绪');
  }

  getEmbedding(index) {
    const start = index * 1536;
    return this.embeddings.slice(start, start + 1536);
  }
}

// 初始化
const db = new VectorDatabase();
window.addEventListener('DOMContentLoaded', () => {
  db.initialize().then(() => {
    document.getElementById('search-btn').disabled = false;
  });
});
```

---

## 二、高性能向量检索

### 1. Web Worker实现并行计算

```javascript
// worker.js - 在独立线程中计算相似度
self.onmessage = function(e) {
  const { queryVector, allEmbeddings, topK } = e.data;
  
  const numVectors = allEmbeddings.length / 1536;
  const similarities = new Float32Array(numVectors);
  
  // 计算余弦相似度
  for (let i = 0; i < numVectors; i++) {
    const offset = i * 1536;
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let j = 0; j < 1536; j++) {
      const a = queryVector[j];
      const b = allEmbeddings[offset + j];
      dotProduct += a * b;
      normA += a * a;
      normB += b * b;
    }
    
    similarities[i] = dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
  
  // 找出top-K
  const indices = Array.from({length: numVectors}, (_, i) => i);
  indices.sort((a, b) => similarities[b] - similarities[a]);
  
  const results = indices.slice(0, topK).map(idx => ({
    index: idx,
    score: similarities[idx]
  }));
  
  self.postMessage(results);
};
```

```javascript
// 主线程调用
class SearchEngine {
  constructor(db) {
    this.db = db;
    this.worker = new Worker('worker.js');
  }

  async search(queryVector, topK = 100) {
    return new Promise((resolve) => {
      this.worker.onmessage = (e) => resolve(e.data);
      this.worker.postMessage({
        queryVector: queryVector,
        allEmbeddings: this.db.embeddings,
        topK: topK
      });
    });
  }
}
```

### 2. 查询向量生成

由于不用外部API生成embedding，有两种方案：

#### 方案A：调用OpenRouter的embedding API
```javascript
async function getQueryEmbedding(text) {
  const response = await fetch('https://openrouter.ai/api/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + OPENROUTER_KEY,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'openai/text-embedding-ada-002',
      input: text
    })
  });
  
  const data = await response.json();
  return data.data[0].embedding;
}
```

#### 方案B：用TF-IDF近似（无需API，纯本地）
```javascript
// 基于预计算的TF-IDF向量做检索
class TFIDFSearchEngine {
  constructor(db) {
    this.db = db;
    this.buildIndex();
  }

  buildIndex() {
    // 构建词汇表
    const vocab = new Set();
    this.db.metadata.forEach(item => {
      item.tokens.split(' ').forEach(token => vocab.add(token));
    });
    
    this.vocab = Array.from(vocab);
    this.idf = this.calculateIDF();
  }

  calculateIDF() {
    const idf = {};
    const N = this.db.metadata.length;
    
    this.vocab.forEach(term => {
      const df = this.db.metadata.filter(item => 
        item.tokens.includes(term)
      ).length;
      idf[term] = Math.log(N / (df + 1));
    });
    
    return idf;
  }

  search(queryText, topK = 100) {
    const queryTerms = queryText.split(/\s+/);
    const scores = this.db.metadata.map((item, idx) => {
      const tokens = item.tokens.split(' ');
      let score = 0;
      
      queryTerms.forEach(term => {
        if (tokens.includes(term)) {
          score += this.idf[term] || 0;
        }
      });
      
      return { index: idx, score };
    });
    
    scores.sort((a, b) => b.score - a.score);
    return scores.slice(0, topK);
  }
}
```

**推荐**：先用方案B（TF-IDF）做粗筛，再用OpenRouter embedding做精排（节省API成本）

---

## 三、知识图谱的三层设计

### 第一层：本地预计算图谱（静态）

在数据准备阶段，预先计算好：

```javascript
// 预处理脚本
const graph = {
  // 时间聚合
  yearStats: {},  // { '1991': { count: 10, categories: {...} } }
  
  // 主题聚类（用K-Means聚类embeddings）
  clusters: [],   // [ { id, centerVector, projectIds, label } ]
  
  // 高频词共现矩阵
  cooccurrence: {},  // { '数字-治理': 45, '乡村-振兴': 128 }
  
  // 学科分布
  categoryTree: {}  // 按category层级结构化
};

fs.writeFileSync('graph.json', JSON.stringify(graph));
```

前端直接加载这个预计算图谱，实现**秒级响应**：

```javascript
// 展示整体概览
async function showOverview() {
  const graph = await fetch('graph.json').then(r => r.json());
  
  // 渲染年份趋势图
  renderYearTrend(graph.yearStats);
  
  // 渲染主题聚类图
  renderClusters(graph.clusters);
  
  // 渲染词云
  renderWordCloud(graph.cooccurrence);
}
```

### 第二层：动态检索图谱（实时）

用户输入关键词后，实时生成局部图谱：

```javascript
async function buildDynamicGraph(keywords) {
  // 1. 本地检索（TF-IDF或向量）
  const results = await searchEngine.search(keywords, 200);
  
  // 2. 提取子集的关系
  const subGraph = {
    nodes: results.map(r => ({
      id: r.index,
      name: db.metadata[r.index].name,
      year: db.metadata[r.index].year,
      score: r.score
    })),
    
    // 计算节点间的相似度（抽样计算，避免O(n²)）
    edges: []
  };
  
  // 只计算top-50之间的相似度
  const topResults = results.slice(0, 50);
  for (let i = 0; i < topResults.length; i++) {
    for (let j = i + 1; j < topResults.length; j++) {
      const sim = cosineSimilarity(
        db.getEmbedding(topResults[i].index),
        db.getEmbedding(topResults[j].index)
      );
      
      if (sim > 0.8) {  // 只保留高相似度边
        subGraph.edges.push({
          source: topResults[i].index,
          target: topResults[j].index,
          weight: sim
        });
      }
    }
  }
  
  return subGraph;
}
```

### 第三层：AI推理图谱（语义）

把检索结果交给大模型深度分析：

```javascript
async function analyzeWithAI(results, keywords) {
  const projects = results.slice(0, 50).map(r => {
    const meta = db.metadata[r.index];
    return `${meta.year}年 ${meta.category} 《${meta.name}》`;
  }).join('\n');
  
  const prompt = `
你是国家社科基金研究专家。用户想研究"${keywords}"，以下是历年相关立项：

${projects}

请以JSON格式返回分析（严格遵循格式，不要有其他文字）：
{
  "themes": [
    {
      "name": "主题名称",
      "projects": ["项目索引，如0,1,2"],
      "keywords": ["核心概念"],
      "trend": "上升/稳定/下降"
    }
  ],
  "timeline": [
    {"period": "年份区间", "focus": "研究重点", "count": 数量}
  ],
  "gaps": [
    {"combination": "概念组合", "reason": "为何是空白"}
  ],
  "suggestions": [
    {"title": "建议选题", "angle": "创新角度", "risk": "风险提示"}
  ]
}`;

  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + OPENROUTER_KEY,
      'Content-Type': 'application/json',
      'HTTP-Referer': window.location.href,
    },
    body: JSON.stringify({
      model: 'deepseek/deepseek-chat',  // 便宜且效果好
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3,  // 降低随机性
      response_format: { type: 'json_object' }  // 强制JSON输出
    })
  });
  
  const data = await response.json();
  return JSON.parse(data.choices[0].message.content);
}
```

---

## 四、完整交互流程

```javascript
// 主搜索函数
async function performSearch() {
  const keywords = document.getElementById('keywords').value;
  showLoading(true);
  
  try {
    // 阶段1：快速预览（使用预计算图谱）
    showQuickPreview(keywords);
    
    // 阶段2：精确检索
    const results = await searchEngine.search(keywords, 200);
    updateResultsCount(results.length);
    
    // 阶段3：构建动态图谱
    const graph = await buildDynamicGraph(keywords);
    renderGraph(graph);
    
    // 阶段4：AI深度分析（后台进行）
    const analysis = await analyzeWithAI(results, keywords);
    renderAnalysis(analysis);
    
    // 阶段5：渲染题目列表
    renderProjectList(results.slice(0, 100));
    
  } catch (error) {
    showError(error);
  } finally {
    showLoading(false);
  }
}

// 快速预览函数
function showQuickPreview(keywords) {
  // 从预计算的clusters中找最相关的
  const relatedClusters = precomputedGraph.clusters.filter(c =>
    keywords.split(' ').some(kw => c.label.includes(kw))
  );
  
  if (relatedClusters.length > 0) {
    document.getElementById('quick-preview').innerHTML = `
      <h3>初步匹配到 ${relatedClusters.length} 个主题方向</h3>
      ${relatedClusters.map(c => `
        <div class="cluster-card">
          <strong>${c.label}</strong>
          <span>${c.projectIds.length} 个相关项目</span>
        </div>
      `).join('')}
    `;
  }
}
```

---

## 五、可视化实现

### 1. 主题聚类力导向图

```javascript
function renderGraph(graph) {
  const option = {
    title: { text: '相关研究主题分布' },
    tooltip: {},
    series: [{
      type: 'graph',
      layout: 'force',
      data: graph.nodes.map(n => ({
        id: n.id,
        name: n.name,
        value: n.score,
        symbolSize: Math.sqrt(n.score) * 50,
        category: n.year < 2010 ? 0 : n.year < 2020 ? 1 : 2
      })),
      links: graph.edges.map(e => ({
        source: e.source,
        target: e.target,
        value: e.weight
      })),
      categories: [
        { name: '2010年前' },
        { name: '2010-2020' },
        { name: '2020年后' }
      ],
      roam: true,
      label: {
        show: true,
        position: 'right',
        formatter: '{b}'
      },
      force: {
        repulsion: 1000,
        edgeLength: [50, 200]
      }
    }]
  };
  
  echarts.init(document.getElementById('graph')).setOption(option);
}
```

### 2. 时间演化河流图

```javascript
function renderTimeline(analysis) {
  const option = {
    title: { text: '研究热度时间演化' },
    xAxis: {
      type: 'category',
      data: analysis.timeline.map(t => t.period)
    },
    yAxis: { type: 'value' },
    series: [{
      type: 'line',
      data: analysis.timeline.map(t => t.count),
      areaStyle: {
        color: {
          type: 'linear',
          x: 0, y: 0, x2: 0, y2: 1,
          colorStops: [
            { offset: 0, color: 'rgba(58,77,233,0.8)' },
            { offset: 1, color: 'rgba(58,77,233,0.1)' }
          ]
        }
      },
      smooth: true,
      markLine: {
        data: [{ type: 'average', name: '平均值' }]
      }
    }]
  };
  
  echarts.init(document.getElementById('timeline')).setOption(option);
}
```

### 3. 研究空白识别（气泡图）

```javascript
function renderGaps(analysis) {
  const option = {
    title: { text: '潜在研究空白' },
    xAxis: { name: '时间新颖度' },
    yAxis: { name: '概念组合稀缺度' },
    series: [{
      type: 'scatter',
      symbolSize: 20,
      data: analysis.gaps.map((g, i) => ({
        value: [
          2024 - (g.lastYear || 2000),  // 时间新颖度
          100 / (g.existingCount || 1), // 稀缺度
          g.combination
        ],
        name: g.combination
      })),
      label: {
        show: true,
        formatter: params => params.value[2]
      }
    }]
  };
  
  echarts.init(document.getElementById('gaps')).setOption(option);
}
```

---

## 六、性能优化技巧

### 1. 索引加速

```javascript
// 为常见查询建立倒排索引
class InvertedIndex {
  constructor(metadata) {
    this.index = {};
    
    metadata.forEach((item, idx) => {
      item.tokens.split(' ').forEach(token => {
        if (!this.index[token]) this.index[token] = [];
        this.index[token].push(idx);
      });
    });
  }

  search(term) {
    return this.index[term] || [];
  }
  
  // 组合查询
  searchAnd(terms) {
    const sets = terms.map(t => new Set(this.search(t)));
    return Array.from(sets[0]).filter(id => 
      sets.every(s => s.has(id))
    );
  }
}

// 两阶段检索：
// 1. 倒排索引粗筛（毫秒级）
// 2. 向量精排（秒级）
async function hybridSearch(keywords, topK) {
  const tokens = keywords.split(/\s+/);
  
  // 粗筛：找出包含任一关键词的候选集
  const candidates = new Set();
  tokens.forEach(token => {
    invertedIndex.search(token).forEach(id => candidates.add(id));
  });
  
  if (candidates.size === 0) {
    return fullVectorSearch(keywords, topK);
  }
  
  // 精排：只对候选集做向量计算
  const queryVector = await getQueryEmbedding(keywords);
  const scores = Array.from(candidates).map(idx => ({
    index: idx,
    score: cosineSimilarity(queryVector, db.getEmbedding(idx))
  }));
  
  scores.sort((a, b) => b.score - a.score);
  return scores.slice(0, topK);
}
```

### 2. 缓存机制

```javascript
// 缓存热门查询
const queryCache = new Map();

async function cachedSearch(keywords) {
  const cacheKey = keywords.toLowerCase().trim();
  
  if (queryCache.has(cacheKey)) {
    console.log('命中缓存');
    return queryCache.get(cacheKey);
  }
  
  const results = await performSearch(keywords);
  queryCache.set(cacheKey, results);
  
  // 限制缓存大小
  if (queryCache.size > 50) {
    const firstKey = queryCache.keys().next().value;
    queryCache.delete(firstKey);
  }
  
  return results;
}
```

---

## 七、数据结构设计总结

### 需要准备的文件

```
/static
  ├─ index.html                 # 主页面
  ├─ styles.css                 # 样式
  ├─ data/
  │   ├─ metadata.json         # 元数据 (~500KB)
  │   ├─ embeddings.bin        # 压缩的向量数据 (~150MB)
  │   ├─ graph.json            # 预计算图谱 (~2MB)
  │   └─ inverted-index.json   # 倒排索引 (~1MB)
  ├─ js/
  │   ├─ database.js           # 数据加载
  │   ├─ search-worker.js      # 向量检索Worker
  │   ├─ ai-client.js          # OpenRouter调用
  │   └─ visualizations.js     # ECharts配置
  └─ lib/
      ├─ echarts.min.js
      └─ pako.min.js           # 解压缩库
```

### metadata.json 格式
```json
[
  {
    "id": "91CYY003",
    "name": "佛典《律藏部分》词汇研究",
    "year": "1991",
    "category": "青年项目",
    "leader": "朱庆之",
    "org": "四川大学汉语史中心",
    "tokens": "佛典 律藏部分 词汇 研究"
  }
]
```

### graph.json 格式
```json
{
  "yearStats": {
    "1991": { "count": 120, "categories": {"青年项目": 45} }
  },
  "clusters": [
    {
      "id": 0,
      "label": "古典文献语言研究",
      "projectIds": [0, 12, 45],
      "keywords": ["古汉语", "词汇", "训诂"]
    }
  ],
  "cooccurrence": {
    "佛典_词汇": 15,
    "数字_治理": 230
  }
}
```

---

## 八、实施时间线

### Week 1：数据准备
- [ ] 编写Python脚本处理6589条数据
- [ ] 生成压缩的embeddings.bin
- [ ] 预计算聚类和统计图谱
- [ ] 构建倒排索引

### Week 2：核心功能
- [ ] 实现数据加载模块
- [ ] 实现向量检索Worker
- [ ] 集成OpenRouter API
- [ ] 基础UI框架

### Week 3：可视化与优化
- [ ] 实现3个核心图表
- [ ] 性能优化（缓存、懒加载）
- [ ] 响应式设计
- [ ] 测试与调试

---

# 【最后的建议】

## 关于API Key安全

不使用Pinecone后，唯一需要暴露的是OpenRouter Key。建议：

### 方案A：Cloudflare Workers代理
```javascript
// worker.js（部署在Cloudflare）
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  const { messages, model } = await request.json()
  
  // 在这里用环境变量存储真实Key
  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${OPENROUTER_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ messages, model })
  })
  
  return response
}
```

前端调用你的Worker而非直接调用OpenRouter。

### 方案B：限额保护
在前端做简单的频率限制：
```javascript
const rateLimiter = {
  calls: [],
  limit: 20,  // 每小时20次
  
  canCall() {
    const now = Date.now();
    this.calls = this.calls.filter(t => now - t < 3600000);
    return this.calls.length < this.limit;
  },
  
  recordCall() {
    this.calls.push(Date.now());
  }
};
```

---

# 【意义回归】

这个纯前端方案的最大价值在于：

1. **零运维成本**：部署到GitHub Pages后永久免费
2. **完全离线可用**：数据下载后可断网使用
3. **隐私友好**：用户查询不经过第三方服务器
4. **可复制性强**：任何人fork你的repo都能部署自己的版本

但要注意**技术不能替代思考**。这个系统应该是**思考的放大器**，而非**思考的替代品**。建议在界面显著位置提醒用户：

> "此工具基于历史数据分析，仅供参考。国家社科选题的成功取决于：
> 1. 对现实重大问题的关切
> 2. 扎实的学术积累
> 3. 创新的研究视角
> 
> 请结合导师指导和自身研究基础综合判断。"

这样既体现了工具的价值，也守住了学术研究的边界。